# This testcase is part of GDB, the GNU debugger.

# Copyright 2007-2014 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# [ev] {{{

load_lib gdbserver-support.exp
load_lib trace-support.exp

# implicitly specify {basename}.c as the source file
standard_testfile

if { [skip_gdbserver_tests] } {
    return 0
}

# We need to use TCL's exec to get the pid.
if [is_remote target] then {
    return 0
}

# compile test program and start gdb {{{

# attempts to compile & link the program in various ways, until it works
#  MAYBE: replace '{debug}' with: [list debug additional_flags=-lrt]
#   (from gdb/testsuite/gdb.threads/siginfo-threads.exp)
if {[gdb_compile_pthreads "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
    return -1
}

# note: function worth looking at (gdb.exp): it ends with the execution of the 'kill' and the 'file {executable}' gdb commands.
clean_restart ${testfile}

# prev: if {[prepare_for_testing $testfile.exp $testfile $srcfile debug]} {
# prev:     return -1
# prev: }
# }}}

# Make sure we're disconnected, in case we're testing with an
# extended-remote board, therefore already connected.
gdb_test "disconnect" ".*"

# [ev] flag to indicate whether we'd need to terminate the gdbserver process
set local_test_running 0

# NOTE: make sure that these signal names are supported by the test program (trace-signals.c)
set signals_to_test [list SIGRTMIN SIGUSR1]
# extract information from our test program {{{
set local_test_program_args {}
foreach stdsigname_now $signals_to_test {
    lappend local_test_program_args -P $stdsigname_now
}
verbose -log "test program args: '$local_test_program_args'"
# FIXME: I don't think the 'runto'/'runto_main' functions are using the 'args' parameter as program parameters, but rather internal ones (like 'no-message')
gdb_test_no_output "set args $local_test_program_args"
# [ev]: prev: 'runto_main' instead of 'runto main ...'
# [ev]: prev: '![runto main "no-message $local_test_program_args"]'
if ![runto_main] {
    return -1 # FIXME: review return code
}

set program_signals_table ""
set test "extract gdb signal names"
gdb_test_multiple "continue" $test {
    -re "\[\r\n\]+starting program(\[\r\n\]+.*\[\r\n\]+)\[^\r\n\]+caught signals: 0\[\r\n\]+ending program\[\r\n\]+" {
	set program_signals_table $expect_out(1,string)
    }
    #? -re "\[\r\n\]+ending program\[\r\n\]+" { fail $test }
}

# TODO: check: exit gdb (+ gdbserver, if any) before continuing
gdb_exit

# XREF: NOTE: keep in sync with the C test source file
set gdbsigname_notfound "notfound"

if { $program_signals_table != "" } {
    foreach stdsigname_now $signals_to_test {
	set test_thissignal_flag 1
	set test "extract signal number for $stdsigname_now"
	# FIXME: do expression matching on $program_signals_table (regexp(3tcl))
	# example:
	#  % regexp {one[\t ]*([^\t ]+)[\t ]*last} {one   two   last} {} m
	#  1
	#  % puts $m
	#  two
	#  %
	set gdbsigname_now $gdbsigname_notfound
	if { ( $test_thissignal_flag != 0 ) && ( [regexp "\[\r\n\]+$stdsigname_now\[\t \]+(\[^\t \n\r\]+)" $program_signals_table {} gdbsigname_now] == 0 ) } {
	    # TODO: report failure
	}
	# update flag
	set test_thissignal_flag [expr { ( $test_thissignal_flag != 0 ) && ( $gdbsigname_now != $gdbsigname_notfound ) }]
	verbose -log "$test: signal '$stdsigname_now' -> '$gdbsigname_now' -- [expr {( ( $test_thissignal_flag != 0 ) ? "will test" : "test will be SKIPPED" )}]"
    }
}

return 0 # FIXME: remove this line when finished

# }}}

# restart gdb
clean_restart ${testfile}
# Make sure we're disconnected, in case we're testing with an
# extended-remote board, therefore already connected.
gdb_test "disconnect" ".*"

if {0} {
    # from gdbserver_download_current_prog():
    #  Download the currently loaded program to the target if necessary.
    #  Return the target system filename.
    set target_exec [gdbserver_download_current_prog]

    gdbserver_start_extended

    gdb_test_no_output "set remote exec-file $target_exec" "set remote exec-file"

    # Start the program running and then wait for a bit, to be sure
    # that it can be attached to.
    set testpid [eval exec $binfile &]
    exec sleep 2
    if { [istarget "*-*-cygwin*"] } {
	# testpid is the Cygwin PID, GDB uses the Windows PID, which might be
	# different due to the way fork/exec works.
	set testpid [ exec ps -e | gawk "{ if (\$1 == $testpid) print \$4; }" ]
    }

    gdb_test "attach $testpid" \
	"Attaching to program: .*, process $testpid.*(in|at).*" \
	"attach to remote program 1"
} else {
    # make life simple by using this "higher-level" function
    #  (when compared to gdbserver_start_extended (gdbserver_download_current_prog), etc.)
    # [ev] prev: gdbserver_run ""
    gdbserver_run [list -i 100 -t 5000]
    set local_test_running 1
}

if { [gdb_target_supports_trace] } then {
    # Test predefined TSVs are uploaded.
    gdb_test_sequence "info tvariables" "check uploaded tsv" {
	"\[\r\n\]+Name\[\t \]+Initial\[\t \]+Current"
	"\[\r\n\]+\\\$trace_timestamp 0"
    }
}

# not_in_main_yet: gdb_test "backtrace" ".*main.*" "backtrace 1"
# FIXME: continue.. gdb_test "b main" # expect: breakpoint notice, then run, then expect the breakpoint to be hit

# answer:
#  Breakpoint 1 at 0x401224: file testsignals.c, line 180.
gdb_test "break main" "\[\r\n\]+Breakpoint *\[0-9\]* *at *\[^\r\n\]+\[\r\n\]" "setting breakpoint @main"
# answer:
#  (gdb) c
#  Continuing.
#
#  Breakpoint 1, main (argc=5, argv=0x7fffffffb938) at testsignals.c:180
#  180             int verbose = 0;
gdb_test_sequence "continue" "run to first breakpoint" {
    "\[\r\n\]+Continuing\[^\r\n\]+\[\r\n\]"
    "\[\r\n\]+Breakpoint *\[0-9\]*, main *\[^\r\n\]+\[\r\n\]"
}

# FIXME: get the value for SIGRTMIN (which seems to expand to '(__libc_current_sigrtmin ())' on my linux dev box) from a program that needs to be compiled (and thus we'd need tcl to extract its value to be used as the signal number to use in both the program and the gdb dialog)
# FIXME: for now, we'll use SIG34
set local_sigrtmin SIG34
# NOTE:
#  (gdb) handle 34 noignore
#  Only signals 1-15 are valid as numeric signals.
#  Use "info signals" for a list of symbolic signals.
#  (gdb) quit

# IDEA: compile a C test program, which will output the symbolic signal names to use
#  (possibly best to specify the signal as a parameter, and then extract the signal names one by one, or by calling the program multiple times)
#  IDEA: look at 'proc standard_testfile' (lib/gdb.exp):
#   NOTE: it executes this line at one point: set binfile [standard_output_file ${testfile}]
#    NOTE: ... which uses the 'global': gdb_test_file_name
#     NOTE: which gets set with: set gdb_test_file_name [file rootname [file tail [lindex $args 0]]]
#       (in 'proc default_gdb_init')

gdb_test "handle $local_sigrtmin pass noprint" \
	".*\[\r\n\]+Signal\[ \t\]\[^\r\n\]+\[\r\n\]+\[^\r\n\]*No\[ \t\]*No\[ \t\]*Yes\[ \t\]*.*" \
	"do not report real-time signals to gdb"
	#-? "\[\r\n\]+Signal\[ \t\]\[^\r\n\]+\[\r\n\]\[^\r\n\]*No\[ \t\]*No\[ \t\]*Yes\[^\r\n\]*\[^\r\n\]" \
	#+ ".*No\[ \t\]*No\[ \t\]*Yes.*" \
	#+ ".*Signal\[ \t\].+\[\r\n\].*No\[ \t\]*No\[ \t\]*Yes.*" \
	#+ ".*\[\r\n\]Signal\[ \t\].+\[\r\n\].*No\[ \t\]*No\[ \t\]*Yes.*" \
	#+ ".*\[\r\n\]Signal\[ \t\].+\[\r\n\]\[^\r\n\]*No\[ \t\]*No\[ \t\]*Yes.*" \

# (gdb) continue
# answer:
#  Continuing.
#  
#  Program received signal SIG34, Real-time event 34.

# TODO: get ideas (for 'handle' command (and others?)) from ~/work/misc/startup_scripts/gdbinit
# answer:
#  (gdb) handle SIG34 noignore
#  Signal        Stop      Print   Pass to program Description
#  SIG34         No        No      Yes             Real-time event 34
#  (gdb)
#
# more sample output:
#  (gdb) handle 34 nopass
#  Only signals 1-15 are valid as numeric signals.
#  Use "info signals" for a list of symbolic signals.
#  (gdb) info signals
#  Signal        Stop      Print   Pass to program Description
#
#  SIGHUP        Yes       Yes     Yes             Hangup
#  SIGINT        Yes       Yes     No              Interrupt
#  SIGQUIT       Yes       Yes     Yes             Quit
#  SIGILL        Yes       Yes     Yes             Illegal instruction
#  SIGTRAP       Yes       Yes     No              Trace/breakpoint trap
#  SIGABRT       Yes       Yes     Yes             Aborted
#  SIGEMT        Yes       Yes     Yes             Emulation trap
#  SIGFPE        Yes       Yes     Yes             Arithmetic exception
#  SIGKILL       Yes       Yes     Yes             Killed
#  SIGBUS        Yes       Yes     Yes             Bus error
#  SIGSEGV       Yes       Yes     Yes             Segmentation fault
#  SIGSYS        Yes       Yes     Yes             Bad system call
#  SIGPIPE       Yes       Yes     Yes             Broken pipe
#  SIGALRM       No        No      Yes             Alarm clock
#  SIGTERM       Yes       Yes     Yes             Terminated
#  SIGURG        No        No      Yes             Urgent I/O condition
#  SIGSTOP       Yes       Yes     Yes             Stopped (signal)
#  SIGTSTP       Yes       Yes     Yes             Stopped (user)
#  SIGCONT       Yes       Yes     Yes             Continued
#  SIGCHLD       No        No      Yes             Child status changed
#  SIGTTIN       Yes       Yes     Yes             Stopped (tty input)
#  SIGTTOU       Yes       Yes     Yes             Stopped (tty output)
#  SIGIO         No        No      Yes             I/O possible
#  SIGXCPU       Yes       Yes     Yes             CPU time limit exceeded
#  SIGXFSZ       Yes       Yes     Yes             File size limit exceeded
#  SIGVTALRM     No        No      Yes             Virtual timer expired
#  SIGPROF       No        No      Yes             Profiling timer expired
#  SIGWINCH      No        No      Yes             Window size changed
#  SIGLOST       Yes       Yes     Yes             Resource lost
#  SIGUSR1       Yes       Yes     Yes             User defined signal 1
#  SIGUSR2       Yes       Yes     Yes             User defined signal 2
#  SIGPWR        Yes       Yes     Yes             Power fail/restart
#  SIGPOLL       No        No      Yes             Pollable event occurred
#  SIGWIND       Yes       Yes     Yes             SIGWIND
#  SIGPHONE      Yes       Yes     Yes             SIGPHONE
#  SIGWAITING    No        No      Yes             Process's LWPs are blocked
#  SIGLWP        No        No      Yes             Signal LWP
#  SIGDANGER     Yes       Yes     Yes             Swap space dangerously low
#  SIGGRANT      Yes       Yes     Yes             Monitor mode granted
#  SIGRETRACT    Yes       Yes     Yes             Need to relinquish monitor mode
#  SIGMSG        Yes       Yes     Yes             Monitor mode data available
#  SIGSOUND      Yes       Yes     Yes             Sound completed
#  SIGSAK        Yes       Yes     Yes             Secure attention
#  SIGPRIO       Yes       Yes     Yes             SIGPRIO
#  SIG33         Yes       Yes     Yes             Real-time event 33
#  SIG34         No        No      Yes             Real-time event 34
#  SIG35         Yes       Yes     Yes             Real-time event 35
#  [...]
#  SIG127        Yes       Yes     Yes             Real-time event 127
#  SIGINFO       Yes       Yes     Yes             Information request
#  EXC_BAD_ACCESS Yes      Yes     Yes             Could not access memory
#  EXC_BAD_INSTRUCTION Yes Yes     Yes             Illegal instruction/operand
#  EXC_ARITHMETIC Yes      Yes     Yes             Arithmetic exception
#  EXC_EMULATION Yes       Yes     Yes             Emulation instruction
#  EXC_SOFTWARE  Yes       Yes     Yes             Software generated exception
#  EXC_BREAKPOINT Yes      Yes     Yes             Breakpoint
#
#  Use the "handle" command to change these tables.
#  (gdb)

gdb_test "continue" \
    ".*\[\r\n\]+Continuing\[^\r\n\]+\[\r\n\].*" \
    "continue program"

# ... ?

if { $local_test_running != 0 } {
    # MAYBE: FIXME: kill the program
}

return 0
# }}}

# trace-signals.exp {{{
# Test attaching to already-running programs using extended-remote.

load_lib gdbserver-support.exp
load_lib trace-support.exp

standard_testfile

if { [skip_gdbserver_tests] } {
    return 0
}

# We need to use TCL's exec to get the pid.
if [is_remote target] then {
    return 0
}

if {[prepare_for_testing $testfile.exp $testfile $srcfile debug]} {
    return -1
}

# Make sure we're disconnected, in case we're testing with an
# extended-remote board, therefore already connected.
gdb_test "disconnect" ".*"

set target_exec [gdbserver_download_current_prog]
gdbserver_start_extended

gdb_test_no_output "set remote exec-file $target_exec" "set remote exec-file"

# Start the program running and then wait for a bit, to be sure
# that it can be attached to.
set testpid [eval exec $binfile &]
exec sleep 2
if { [istarget "*-*-cygwin*"] } {
    # testpid is the Cygwin PID, GDB uses the Windows PID, which might be
    # different due to the way fork/exec works.
    set testpid [ exec ps -e | gawk "{ if (\$1 == $testpid) print \$4; }" ]
}

gdb_test "attach $testpid" \
    "Attaching to program: .*, process $testpid.*(in|at).*" \
    "attach to remote program 1"

if { [gdb_target_supports_trace] } then {
    # Test predefined TSVs are uploaded.
    gdb_test_sequence "info tvariables" "check uploaded tsv" {
	"\[\r\n\]+Name\[\t \]+Initial\[\t \]+Current"
	"\[\r\n\]+\\\$trace_timestamp 0"
    }
}

gdb_test "backtrace" ".*main.*" "backtrace 1"

gdb_test "detach" "Detaching from program.*process.*"
gdb_test "backtrace" "No stack\\." "backtrace with no program"

gdb_test "attach $testpid" \
    "Attaching to program: .*, process $testpid.*(in|at).*" \
    "attach to remote program 2"
gdb_test "backtrace" ".*main.*" "backtrace 2"

gdb_test "kill" "" "kill" "Kill the program being debugged.*" "y"
gdb_test_no_output "monitor exit"
# }}}

# gdb/testsuite/gdb.server/server-mon.exp {{{
# Test gdbserver monitor commands.

load_lib gdbserver-support.exp

standard_testfile server.c

if { [skip_gdbserver_tests] } {
    return 0
}

if {[prepare_for_testing $testfile.exp $testfile $srcfile debug]} {
    return -1
}

# Make sure we're disconnected, in case we're testing with an
# extended-remote board, therefore already connected.
gdb_test "disconnect" ".*"

gdbserver_run ""

gdb_test_multiple "monitor help" "monitor help" {
    -re "Unknown monitor command.*$gdb_prompt $" {
	fail "monitor help"
    }
    -re "The following monitor commands.*$gdb_prompt $" {
	pass "monitor help"
    }
}

gdb_test "monitor" "Unknown monitor command.*Protocol error.*"

gdb_test "monitor set debug 1" "Debug output enabled\\."
gdb_test "monitor set debug 0" "Debug output disabled\\."
gdb_test "monitor set remote-debug 1" "Protocol debug output enabled\\."
gdb_test "monitor set remote-debug 0" "Protocol debug output disabled\\."
gdb_test "monitor set debug-format all" \
    "All extra debug format options enabled\\."
gdb_test "monitor set debug-format none" \
    "All extra debug format options disabled\\."
# }}}
