# This testcase is part of GDB, the GNU debugger.

# Copyright 2007-2014 Free Software Foundation, Inc.

# This program is free software; you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation; either version 3 of the License, or
# (at your option) any later version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

# to be put in lib/gdb.exp {{{

#   Define actions for a breakpoint / tracepoint
#   Arguments:
#	bptptype   -- either "breakpoint" or "tracepoint"
#       actions_command -- the command used to create the actions.
#                          either "actions" or "commands".
#			empty string: use default for the bptptype
#	testname   -- identifying string for pass/fail output
#			empty string: calculate a test name
#	bptpid     -- to which breakpoint(s)/tracepoint(s) do these actions apply? (optional)
#			empty string: use the last set one ($bpnum or $tpnum)
#	args       -- list of actions to be defined.
#   Returns:
#	zero       -- success
#	non-zero   -- failure
#
# NOTE: this has been based on gdb_trace_setactions_command (lib/trace-support.exp)

proc gdb_breakpoint_or_tracepoint_setactions_command { bptptype actions_command testname bptpid args } {
    global gdb_prompt

    set bptptype_is_breakpoint [ expr { ( $bptptype == "breakpoint" ) } ]
    # optionally get last bptpid ($bpnum or $tpnum)
    if { $bptpid == "" } {
	set bptpid [ gdb_readexpr [ expr { $bptptype_is_breakpoint ? {$bpnum} : {$tpnum} } ] ]
    }
    if { $actions_command == "" } {
	set actions_command [ expr { $bptptype_is_breakpoint ? "commands" : "actions" } ]
    }
    if { $testname == "" } {
	set testname "setting $actions_command for $bptptype $bptpid"
    }

    set state 0
    set passfail "pass"
    send_gdb "$actions_command $bptpid\n"
    set expected_result ""
    gdb_expect 5 {
	-re "No $bptptype number .*$gdb_prompt $" {
	    fail $testname
	    return 1
	}
	# ref: Type commands for breakpoint(s) 4, one per line.
	# ref: Enter actions for tracepoint 1, one per line.
	-re "(?:(?:Enter actions for\[^\r\n\]*\[ \t\]tracepoint)|(?:Type commands for\[^\r\n\]*\[ \t\]breakpoint))\[^\r\n\]*\\m$bptpid\\M\.*>$" {
	    if { [llength $args] > 0 } {
		set lastcommand "[lindex $args $state]"
		send_gdb "[lindex $args $state]\n"
		incr state
		set expected_result [lindex $args $state]
		incr state
	    } else {
		send_gdb "end\n"
	    }
	    exp_continue
	}
	-re "\(.*\)\[\r\n\]+\[ \t]*>$" {
	    if { $expected_result != "" } {
		regsub "^\[^\r\n\]+\[\r\n\]+" "$expect_out(1,string)" "" out
		if ![regexp $expected_result $out] {
		    set passfail "fail"
		}
		set expected_result ""
	    }
	    if { $state < [llength $args] } {
		send_gdb "[lindex $args $state]\n"
		incr state
		set expected_result [lindex $args $state]
		incr state
	    } else {
		send_gdb "end\n"
		set expected_result ""
	    }
	    exp_continue
	}
	-re "\(.*\)$gdb_prompt $" {
	    if { $expected_result != "" } {
		if ![regexp $expected_result $expect_out(1,string)] {
		    set passfail "fail"
		}
		set expected_result ""
	    }
	    if { [llength $args] < $state } {
		set passfail "fail"
	    }
	}
	default {
	    set passfail "fail"
	}
    }
    if { $testname != "" } {
	$passfail $testname
    }
    if { $passfail == "pass" } then { 
	return 0
    } else {
	return 1
    }
}

# }}}

# [ev] {{{

load_lib "gdbserver-support.exp"
load_lib "trace-support.exp"

if { [skip_gdbserver_tests] } {
    return 0
}

# FIXME: make this test script work in the 'is_remote' (true) case
# We need to use TCL's exec to get the pid.
#+? if [is_remote target] then {
#+?     return 0
#+? }

# configurable values {{{
# NOTE: make sure that these signal names are supported by the test program (trace-signals.c)
set signals_to_test [list SIGRTMIN SIGUSR1]
set test_trace_signals_duration_ms 3000
set test_trace_signals_timeout_safety_factor_seconds 5
set test_trace_signals_timeout_complete_test_seconds [expr { ( $test_trace_signals_duration_ms / 1000 ) + $test_trace_signals_timeout_safety_factor_seconds }]
# }}}

#+? gdb_exit
#+? gdb_start
# implicitly specify {basename}.c as the source file
standard_testfile

# compile test program {{{

# attempts to compile & link the program in various ways, until it works
#  MAYBE: replace '{debug}' with: [list debug additional_flags=-lrt]
#   (from gdb/testsuite/gdb.threads/siginfo-threads.exp)
if {[gdb_compile_pthreads "${srcdir}/${subdir}/${srcfile}" "${binfile}" executable {debug}] != "" } {
    return -1
}

# }}}

# [ev] flag to indicate whether we'd need to terminate the gdbserver process
set local_test_running 0

# extract information from our test program {{{
# NOTE: there are other ways to get the signal numbers (and/or gdb signal
#        names):
#
#  1. let the debugger "catch" signals, and then parse its output. this other
#     approach would have the benefit of not needing our test program to do
#     this "signal name guessing".
#
#     example:
#      $ gdb --quiet --nw --nx --args kill -s SIGRTMIN 0
#      Reading symbols from /bin/kill...(no debugging symbols found)...done.
#      (gdb) c
#      The program is not being run.
#      (gdb) r
#      Starting program: /bin/kill -s SIGRTMIN 0
#      
#      Program received signal SIG34, Real-time event 34.
#      0x00007ffff788a497 in kill () at ../sysdeps/unix/syscall-template.S:82
#      82      ../sysdeps/unix/syscall-template.S: No such file or directory.
#              in ../sysdeps/unix/syscall-template.S
#      Current language:  auto
#      The current source language is "auto; currently asm".
#      (gdb)
#
#     in the above example, we're using the pid == 0 to send a signal to all
#     processes in kill's process group (which I'm guessing only contains the
#     'kill' program itself).
#
#     according to kill(2):
#
#      If pid equals 0, then sig is sent to every process in the process group
#      of the calling process.
#
#  1.1. use our program instead of 'kill'. advantages: no external
#     dependencies, no "process group" assumptions.
#
#  2. parse the output of 'kill -l {signal}'
#     example:
#
#      $ kill -l
#       1) SIGHUP       2) SIGINT       3) SIGQUIT      4) SIGILL       5) SIGTRAP
#       6) SIGABRT      7) SIGBUS       8) SIGFPE       9) SIGKILL     10) SIGUSR1
#      11) SIGSEGV     12) SIGUSR2     13) SIGPIPE     14) SIGALRM     15) SIGTERM
#      16) SIGSTKFLT   17) SIGCHLD     18) SIGCONT     19) SIGSTOP     20) SIGTSTP
#      21) SIGTTIN     22) SIGTTOU     23) SIGURG      24) SIGXCPU     25) SIGXFSZ
#      26) SIGVTALRM   27) SIGPROF     28) SIGWINCH    29) SIGIO       30) SIGPWR
#      31) SIGSYS      34) SIGRTMIN    35) SIGRTMIN+1  36) SIGRTMIN+2  37) SIGRTMIN+3
#      38) SIGRTMIN+4  39) SIGRTMIN+5  40) SIGRTMIN+6  41) SIGRTMIN+7  42) SIGRTMIN+8
#      43) SIGRTMIN+9  44) SIGRTMIN+10 45) SIGRTMIN+11 46) SIGRTMIN+12 47) SIGRTMIN+13
#      48) SIGRTMIN+14 49) SIGRTMIN+15 50) SIGRTMAX-14 51) SIGRTMAX-13 52) SIGRTMAX-12
#      53) SIGRTMAX-11 54) SIGRTMAX-10 55) SIGRTMAX-9  56) SIGRTMAX-8  57) SIGRTMAX-7
#      58) SIGRTMAX-6  59) SIGRTMAX-5  60) SIGRTMAX-4  61) SIGRTMAX-3  62) SIGRTMAX-2
#      63) SIGRTMAX-1  64) SIGRTMAX
#      $ kill -l SIGRTMIN
#      34
#      $

set local_test_program_args {}
foreach stdsigname_now $signals_to_test {
    lappend local_test_program_args -P $stdsigname_now
}
verbose -log "test program args: '$local_test_program_args'"

set test "run test program (without debugger) to extract gdb signal names"
# prev: gdb_test_no_output "set args $local_test_program_args"
# prev: gdbserver_run "$local_test_program_args"
# remote_exec returns a 2-element list: EXITCODE PROGRAM_OUTPUT
set signals_program_exec_list [ remote_exec target "${binfile}" "$local_test_program_args"  ]
#? gdb_reinitialize_dir $srcdir/$subdir
# an EXITCODE == -1 signals a command execution error
if { [lindex $signals_program_exec_list 0] < 0 } {
    # FIXME: improve error reporting
    fail "$test"
    return -1
}
# get command output (2nd list element) into a handy variable
set signals_program_exec_output [lindex $signals_program_exec_list 1]

set program_signals_table ""
set test "extract gdb signal names"
if { !( [regexp {^starting program([\r\n]+.*[\r\n]+)[^\r\n]+caught signals: 0[\r\n]+ending program[\r\n]+} $signals_program_exec_output {} program_signals_table] != 0 ) } {
    # FIXME: improve error reporting
    fail "$test"
    return -1
}
verbose -log "program_signals_table: '$program_signals_table'"

# XREF: NOTE: keep in sync with the C test source file
set gdbsigname_notfound "notfound"
# }}}

# note: from gdb/testsuite/lib/gdb.exp
global gdb_test_timeout

if { $program_signals_table != "" } {
    foreach stdsigname_now $signals_to_test {
	set test_thissignal_flag 1
	set test "extract signal number for $stdsigname_now"

	# set gdbsigname_now {{{
	# do expression matching on $program_signals_table (regexp(3tcl))
	# example:
	#  % regexp {one[\t ]*([^\t ]+)[\t ]*last} {one   two   last} {} m
	#  1
	#  % puts $m
	#  two
	#  %
	set gdbsigname_now $gdbsigname_notfound
	if { ( $test_thissignal_flag != 0 ) && ( [regexp "\[\r\n\]+$stdsigname_now\[\t \]+(\[^\t \n\r\]+)" $program_signals_table {} gdbsigname_now] == 0 ) } {
	    fail "$test"
	    continue
	}
	# update flag
	set test_thissignal_flag [expr { ( $test_thissignal_flag != 0 ) && ( $gdbsigname_now != $gdbsigname_notfound ) }]
	# }}}

	verbose -log "$test: signal '$stdsigname_now' -> '$gdbsigname_now' -- [expr {( ( $test_thissignal_flag != 0 ) ? "will test" : "test will be SKIPPED" )}]"

	set test_name_prefix "tracing signal processing code (signal $stdsigname_now):"

	if { ( $test_thissignal_flag != 0 ) } {

	    # restart gdb
	    clean_restart ${testfile}
	    # Make sure we're disconnected, in case we're testing with an
	    # extended-remote board, therefore already connected.
	    if { !( \
		    [ gdb_test "disconnect" ".*" ] == 0 \
		) } {
		continue
	    }

	    if { !( \
		    [ gdbserver_run [list -s $stdsigname_now -i 100 -t $test_trace_signals_duration_ms] ] == 0
		) } {
		continue
	    }

	    #-? # FIXME: as gdbserver_start does not expose server_spawn_id
	    #-? #  (which is 'local' (non-'global') by default), we don't
	    #-? #  seem to have a way to access the gdbserver spawn id =>
	    #-? #  we can't 'close' or otherwise use that.
	    #-? #  (gdbserver_run -> gdbserver_spawn -> gdbserver_start -> remote_spawn)
	    #-? # NOTE: however, we can use our "white-box" knowledge and hope that
	    #-? #  there had not been any other 'spawn' invocations =>
	    #-? #  spawn_id should still be valid
	    #-? global spawn_id
	    #-? verbose -log "spawn_id: '$spawn_id'"

	    set local_test_running 1

	    if { [gdb_target_supports_trace] } then {
		# Test predefined TSVs are uploaded.
		gdb_test_sequence "info tvariables" "$test_name_prefix check uploaded tsv" {
		    "\[\r\n\]+Name\[\t \]+Initial\[\t \]+Current"
		    "\[\r\n\]+\\\$trace_timestamp 0"
		}
	    } else {
		untested "$test_name_prefix (target does not support tracing)"
		continue
	    }

	    # ref (my old gdb script): set trace-buffer-size 102400000
	    # FIXME: make trace buffer size dependant on the expected number of
	    #  tracing "entries"/"samples"
	    if { !( \
		    [ gdb_test_no_output "set trace-buffer-size [expr { 32 * 1024 * 1024 }]" \
			"$test_name_prefix set trace buffer size" \
		    ] == 0 \
		) } {
		continue
	    }

	    if { 0 } {
		# does not seem to work: it does not seem to 'continue' the program,
		# so this breakpoint is actually hit near the end of this test case
		# (gdb_continue_to_end invocation)
		runto_main
	    } elseif { 0 } {
		# same problem as runto_main
		runto main
	    } else {
		# answer:
		#  Breakpoint 1 at 0x401224: file testsignals.c, line 180.
		#+ gdb_test "break main" "\[\r\n\]+Breakpoint *\[0-9\]* *at *\[^\r\n\]+\[\r\n\]" "$test_name_prefix setting breakpoint @main"
		# note: gdb_breakpoint allows certain "option" modifiers (see lib/gdb.exp)
		if { !( \
			[ gdb_breakpoint main ] \
		    ) } {
		    continue
		}
		# answer:
		#  (gdb) c
		#  Continuing.
		#
		#  Breakpoint 1, main (argc=5, argv=0x7fffffffb938) at testsignals.c:180
		#  180             int verbose = 0;
		if { !( \
			[ gdb_test_sequence "continue" "$test_name_prefix run to first breakpoint" { \
				"\[\r\n\]+Continuing\[^\r\n\]+\[\r\n\]" \
				"\[\r\n\]+Breakpoint *\[0-9\]*, *main *\[^\r\n\]+\[\r\n\]" \
			    } \
			] == 0 \
		    ) } {
		    continue
		}
	    }
	    send_user {about to run the handle "signal" command\n}

		#-? "\[\r\n\]+Signal\[ \t\]\[^\r\n\]+\[\r\n\]\[^\r\n\]*No\[ \t\]*No\[ \t\]*Yes\[^\r\n\]*\[^\r\n\]" \
		#+ ".*No\[ \t\]*No\[ \t\]*Yes.*" \
		#+ ".*Signal\[ \t\].+\[\r\n\].*No\[ \t\]*No\[ \t\]*Yes.*" \
		#+ ".*\[\r\n\]Signal\[ \t\].+\[\r\n\].*No\[ \t\]*No\[ \t\]*Yes.*" \
		#+ ".*\[\r\n\]Signal\[ \t\].+\[\r\n\]\[^\r\n\]*No\[ \t\]*No\[ \t\]*Yes.*" \
		#
	    if { !( \
		    [ gdb_test "handle $gdbsigname_now pass noprint" \
			    ".*\[\r\n\]+Signal\[ \t\]\[^\r\n\]+\[\r\n\]+\[^\r\n\]*No\[ \t\]*No\[ \t\]*Yes\[ \t\]*.*" \
			    "$test_name_prefix do not report $gdbsigname_now signal to gdb" \
		    ] == 0 \
		) } {
		continue
	    }
	    send_user {after running the handle "signal" command\n}

	    # (gdb) continue
	    # answer:
	    #  Continuing.
	    #  
	    #  Program received signal SIG34, Real-time event 34.

	    # TODO: get ideas (for 'handle' command (and others?)) from ~/work/misc/startup_scripts/gdbinit
	    # answer:
	    #  (gdb) handle SIG34 noignore
	    #  Signal        Stop      Print   Pass to program Description
	    #  SIG34         No        No      Yes             Real-time event 34
	    #  (gdb)
	    #
	    # more sample output:
	    #  (gdb) handle 34 nopass
	    #  Only signals 1-15 are valid as numeric signals.
	    #  Use "info signals" for a list of symbolic signals.
	    #  (gdb) info signals
	    #  Signal        Stop      Print   Pass to program Description
	    #
	    #  SIGHUP        Yes       Yes     Yes             Hangup
	    #  SIGINT        Yes       Yes     No              Interrupt
	    #  SIGQUIT       Yes       Yes     Yes             Quit
	    #  SIGILL        Yes       Yes     Yes             Illegal instruction
	    #  SIGTRAP       Yes       Yes     No              Trace/breakpoint trap
	    #  SIGABRT       Yes       Yes     Yes             Aborted
	    #  SIGEMT        Yes       Yes     Yes             Emulation trap
	    #  SIGFPE        Yes       Yes     Yes             Arithmetic exception
	    #  SIGKILL       Yes       Yes     Yes             Killed
	    #  SIGBUS        Yes       Yes     Yes             Bus error
	    #  SIGSEGV       Yes       Yes     Yes             Segmentation fault
	    #  SIGSYS        Yes       Yes     Yes             Bad system call
	    #  SIGPIPE       Yes       Yes     Yes             Broken pipe
	    #  SIGALRM       No        No      Yes             Alarm clock
	    #  SIGTERM       Yes       Yes     Yes             Terminated
	    #  SIGURG        No        No      Yes             Urgent I/O condition
	    #  SIGSTOP       Yes       Yes     Yes             Stopped (signal)
	    #  SIGTSTP       Yes       Yes     Yes             Stopped (user)
	    #  SIGCONT       Yes       Yes     Yes             Continued
	    #  SIGCHLD       No        No      Yes             Child status changed
	    #  SIGTTIN       Yes       Yes     Yes             Stopped (tty input)
	    #  SIGTTOU       Yes       Yes     Yes             Stopped (tty output)
	    #  SIGIO         No        No      Yes             I/O possible
	    #  SIGXCPU       Yes       Yes     Yes             CPU time limit exceeded
	    #  SIGXFSZ       Yes       Yes     Yes             File size limit exceeded
	    #  SIGVTALRM     No        No      Yes             Virtual timer expired
	    #  SIGPROF       No        No      Yes             Profiling timer expired
	    #  SIGWINCH      No        No      Yes             Window size changed
	    #  SIGLOST       Yes       Yes     Yes             Resource lost
	    #  SIGUSR1       Yes       Yes     Yes             User defined signal 1
	    #  SIGUSR2       Yes       Yes     Yes             User defined signal 2
	    #  SIGPWR        Yes       Yes     Yes             Power fail/restart
	    #  SIGPOLL       No        No      Yes             Pollable event occurred
	    #  SIGWIND       Yes       Yes     Yes             SIGWIND
	    #  SIGPHONE      Yes       Yes     Yes             SIGPHONE
	    #  SIGWAITING    No        No      Yes             Process's LWPs are blocked
	    #  SIGLWP        No        No      Yes             Signal LWP
	    #  SIGDANGER     Yes       Yes     Yes             Swap space dangerously low
	    #  SIGGRANT      Yes       Yes     Yes             Monitor mode granted
	    #  SIGRETRACT    Yes       Yes     Yes             Need to relinquish monitor mode
	    #  SIGMSG        Yes       Yes     Yes             Monitor mode data available
	    #  SIGSOUND      Yes       Yes     Yes             Sound completed
	    #  SIGSAK        Yes       Yes     Yes             Secure attention
	    #  SIGPRIO       Yes       Yes     Yes             SIGPRIO
	    #  SIG33         Yes       Yes     Yes             Real-time event 33
	    #  SIG34         No        No      Yes             Real-time event 34
	    #  SIG35         Yes       Yes     Yes             Real-time event 35
	    #  [...]
	    #  SIG127        Yes       Yes     Yes             Real-time event 127
	    #  SIGINFO       Yes       Yes     Yes             Information request
	    #  EXC_BAD_ACCESS Yes      Yes     Yes             Could not access memory
	    #  EXC_BAD_INSTRUCTION Yes Yes     Yes             Illegal instruction/operand
	    #  EXC_ARITHMETIC Yes      Yes     Yes             Arithmetic exception
	    #  EXC_EMULATION Yes       Yes     Yes             Emulation instruction
	    #  EXC_SOFTWARE  Yes       Yes     Yes             Software generated exception
	    #  EXC_BREAKPOINT Yes      Yes     Yes             Breakpoint
	    #
	    #  Use the "handle" command to change these tables.
	    #  (gdb)

	    # set tracepoints {{{
	    # tracepoint #1 {{{
	    set test "$test_name_prefix set tracepoint #1"
	    set tracepoint_signalhandler [gdb_gettpnum signal_handler_function_signaltomain]
	    if { $tracepoint_signalhandler == -1 } {
		fail "$test"
		continue
	    }
	    if { [ \
		gdb_trace_setactions_command "actions" \
		    "$test_name_prefix set tracepoint #1 actions" \
		    $tracepoint_signalhandler \
			{collect $regs} {^$} \
			{collect g_signals_caught} {^$} \
		] != 0 } {
		#fail "$test"
		continue
	    }
	    # }}}

	    # tracepoint #2 {{{
	    set test "$test_name_prefix set tracepoint #2"
	    set tracepoint_mainwait [gdb_gettpnum donothing_mainwait_interrupted]
	    if { $tracepoint_mainwait == -1 } {
		fail "$test"
		continue
	    }
	    if { [ \
		gdb_trace_setactions_command "actions" \
		    "$test_name_prefix set tracepoint #2 actions" \
		    $tracepoint_mainwait \
			{collect $regs} {^$} \
		] != 0 } {
		#fail "$test"
		continue
	    }
	    # }}}

	    # }}}

	    # FIXME: put breakpoint after tracing is done
	    #  ref: b donothing_main_end
	    #  ref: commands
	    #  ref:  tstop
	    #  ref: end
	    # ref: proc gdb_breakpoint { function args }
	    #  (gdb) b _init
	    #  Breakpoint 1 at 0x401f40
	    #  (gdb) commands
	    #  Type commands for when breakpoint 1 is hit, one per line.
	    #  End with a line saying just "end".
	    #  >tstart
	    #  >end
	    #  (gdb)
	    #
	    # ref: proc gdb_breakpoint_or_tracepoint_setactions_command { bptptype actions_command testname bptpid args }
	    set local_bptp_location_main_end {donothing_main_end}
	    set local_bptp_location $local_bptp_location_main_end
	    # FIXME: MAYBE: we don't want to run the 'tstop' as a breakpoint command, but rather run the command(s) individually
	    if { !( \
		    [ gdb_breakpoint $local_bptp_location ] \
		    && \
		    [ gdb_breakpoint_or_tracepoint_setactions_command "breakpoint" {} \
			"$test_name_prefix setting breakpoint commands for $local_bptp_location" \
			{} \
			    {tstop} {^$} \
		    ] == 0 \
		) } {
		continue
	    }

	    # ref: # gdb_test COMMAND PATTERN MESSAGE QUESTION RESPONSE
	    # ref: # gdb_test_no_output COMMAND MESSAGE

	    if { !( \
		    [ gdb_test "info sharedlibrary" \
			{.*} \
			"$test_name_prefix getting library information (no real testing here)" \
		    ] == 0 \
		) } {
		continue
	    }

	    # FIXME: run tstart
	    #  ref: b main
	    #  ref: commands
	    #  ref:  tstart
	    #  ref:  info sharedlibrary
	    #  ref:  continue
	    #  ref: end
	    if { !( \
		    [ gdb_test_no_output "tstart" \
			"$test_name_prefix start tracing" \
		    ] == 0 \
		) } {
		continue
	    }

	    set timeout_saved $gdb_test_timeout
	    # give test enough time to finish
	    set gdb_test_timeout $test_trace_signals_timeout_complete_test_seconds

		# continue program until the breakpoint @ donothing_main_end gets hit
		#  NOTE: this is where the "buggy" gdbserver would crash (gdb_assert()?)
		# sample output: Breakpoint 2, donothing_main_end () at testsignals.c:21
		set local_test_command_success \
		    [ expr \
			[ gdb_test "continue" \
			    ".*\[\r\n\]\[Bb\]reakpoint \\m\[0-9\]+\\M\[^\r\n\]+\\m$local_bptp_location_main_end\\M\[^\r\n\]+\\mat\\M.*" \
			    "$test_name_prefix continue program until end of main()" \
			] == 0 \
		    ]

	    set gdb_test_timeout $timeout_saved

	    if { !( $local_test_command_success ) } {
		continue
	    }

	    # TODO: LATER: execute 'tstop' gdb command here (instead of being a command within the breakpoint)

	    # FIXME: validate a few of the tracing results (g_signals_caught having a minimum value (computed from the program arguments))
	    #  #1:
	    #   FIXME: run tstatus, and validate the number of collected "frames" (?) agains g_signals_caught (frames >= g_signals_caught)
	    #  #2:
	    #   FIXME: tfind start
	    #   FIXME: looping through results obtained through 'tfind'
	    #   FIXME: tfind end

	    set timeout_saved $gdb_test_timeout
	    # give test enough time to finish
	    set gdb_test_timeout $test_trace_signals_timeout_complete_test_seconds

		# prev: gdb_test "continue" \
		# prev:     ".*\[\r\n\]+Continuing\[^\r\n\]+\[\r\n\].*" \
		# prev:     "$test_name_prefix continue program"
		gdb_continue_to_end \
		    "$test_name_prefix continue program" \
		    {continue} \
		    1

	    set gdb_test_timeout $timeout_saved

	    gdb_exit
	    # FIXME: see command regarding server_spawn_id, above
	} else {
	    untested "$test_name_prefix (unsupported/unavailable signal)"
	}
    }
}

# just in case the last loop iteration has finished with 'continue',
#  we'll make sure that we have no active gdb sessions
gdb_exit

return 0 # FIXME: remove this line when finished

# }}}

# restart gdb
clean_restart ${testfile}
# Make sure we're disconnected, in case we're testing with an
# extended-remote board, therefore already connected.
gdb_test "disconnect" ".*"

if {0} {
    # from gdbserver_download_current_prog():
    #  Download the currently loaded program to the target if necessary.
    #  Return the target system filename.
    set target_exec [gdbserver_download_current_prog]

    gdbserver_start_extended

    gdb_test_no_output "set remote exec-file $target_exec" "set remote exec-file"

    # Start the program running and then wait for a bit, to be sure
    # that it can be attached to.
    set testpid [eval exec $binfile &]
    exec sleep 2
    if { [istarget "*-*-cygwin*"] } {
	# testpid is the Cygwin PID, GDB uses the Windows PID, which might be
	# different due to the way fork/exec works.
	set testpid [ exec ps -e | gawk "{ if (\$1 == $testpid) print \$4; }" ]
    }

    gdb_test "attach $testpid" \
	"Attaching to program: .*, process $testpid.*(in|at).*" \
	"attach to remote program 1"
} else {
    # make life simple by using this "higher-level" function
    #  (when compared to gdbserver_start_extended (gdbserver_download_current_prog), etc.)
    # [ev] prev: gdbserver_run ""
    gdbserver_run [list -i 100 -t 5000]
    set local_test_running 1
}

if { [gdb_target_supports_trace] } then {
    # Test predefined TSVs are uploaded.
    gdb_test_sequence "info tvariables" "check uploaded tsv" {
	"\[\r\n\]+Name\[\t \]+Initial\[\t \]+Current"
	"\[\r\n\]+\\\$trace_timestamp 0"
    }
}

# not_in_main_yet: gdb_test "backtrace" ".*main.*" "backtrace 1"
# FIXME: continue.. gdb_test "b main" # expect: breakpoint notice, then run, then expect the breakpoint to be hit

# answer:
#  Breakpoint 1 at 0x401224: file testsignals.c, line 180.
gdb_test "break main" "\[\r\n\]+Breakpoint *\[0-9\]* *at *\[^\r\n\]+\[\r\n\]" "setting breakpoint @main"
# answer:
#  (gdb) c
#  Continuing.
#
#  Breakpoint 1, main (argc=5, argv=0x7fffffffb938) at testsignals.c:180
#  180             int verbose = 0;
gdb_test_sequence "continue" "run to first breakpoint" {
    "\[\r\n\]+Continuing\[^\r\n\]+\[\r\n\]"
    "\[\r\n\]+Breakpoint *\[0-9\]*, main *\[^\r\n\]+\[\r\n\]"
}

# FIXME: get the value for SIGRTMIN (which seems to expand to '(__libc_current_sigrtmin ())' on my linux dev box) from a program that needs to be compiled (and thus we'd need tcl to extract its value to be used as the signal number to use in both the program and the gdb dialog)
# FIXME: for now, we'll use SIG34
set local_sigrtmin SIG34
# NOTE:
#  (gdb) handle 34 noignore
#  Only signals 1-15 are valid as numeric signals.
#  Use "info signals" for a list of symbolic signals.
#  (gdb) quit

# IDEA: compile a C test program, which will output the symbolic signal names to use
#  (possibly best to specify the signal as a parameter, and then extract the signal names one by one, or by calling the program multiple times)
#  IDEA: look at 'proc standard_testfile' (lib/gdb.exp):
#   NOTE: it executes this line at one point: set binfile [standard_output_file ${testfile}]
#    NOTE: ... which uses the 'global': gdb_test_file_name
#     NOTE: which gets set with: set gdb_test_file_name [file rootname [file tail [lindex $args 0]]]
#       (in 'proc default_gdb_init')

gdb_test "handle $local_sigrtmin pass noprint" \
	".*\[\r\n\]+Signal\[ \t\]\[^\r\n\]+\[\r\n\]+\[^\r\n\]*No\[ \t\]*No\[ \t\]*Yes\[ \t\]*.*" \
	"do not report real-time signals to gdb"
	#-? "\[\r\n\]+Signal\[ \t\]\[^\r\n\]+\[\r\n\]\[^\r\n\]*No\[ \t\]*No\[ \t\]*Yes\[^\r\n\]*\[^\r\n\]" \
	#+ ".*No\[ \t\]*No\[ \t\]*Yes.*" \
	#+ ".*Signal\[ \t\].+\[\r\n\].*No\[ \t\]*No\[ \t\]*Yes.*" \
	#+ ".*\[\r\n\]Signal\[ \t\].+\[\r\n\].*No\[ \t\]*No\[ \t\]*Yes.*" \
	#+ ".*\[\r\n\]Signal\[ \t\].+\[\r\n\]\[^\r\n\]*No\[ \t\]*No\[ \t\]*Yes.*" \

# (gdb) continue
# answer:
#  Continuing.
#  
#  Program received signal SIG34, Real-time event 34.

# TODO: get ideas (for 'handle' command (and others?)) from ~/work/misc/startup_scripts/gdbinit
# answer:
#  (gdb) handle SIG34 noignore
#  Signal        Stop      Print   Pass to program Description
#  SIG34         No        No      Yes             Real-time event 34
#  (gdb)
#
# more sample output:
#  (gdb) handle 34 nopass
#  Only signals 1-15 are valid as numeric signals.
#  Use "info signals" for a list of symbolic signals.
#  (gdb) info signals
#  Signal        Stop      Print   Pass to program Description
#
#  SIGHUP        Yes       Yes     Yes             Hangup
#  SIGINT        Yes       Yes     No              Interrupt
#  SIGQUIT       Yes       Yes     Yes             Quit
#  SIGILL        Yes       Yes     Yes             Illegal instruction
#  SIGTRAP       Yes       Yes     No              Trace/breakpoint trap
#  SIGABRT       Yes       Yes     Yes             Aborted
#  SIGEMT        Yes       Yes     Yes             Emulation trap
#  SIGFPE        Yes       Yes     Yes             Arithmetic exception
#  SIGKILL       Yes       Yes     Yes             Killed
#  SIGBUS        Yes       Yes     Yes             Bus error
#  SIGSEGV       Yes       Yes     Yes             Segmentation fault
#  SIGSYS        Yes       Yes     Yes             Bad system call
#  SIGPIPE       Yes       Yes     Yes             Broken pipe
#  SIGALRM       No        No      Yes             Alarm clock
#  SIGTERM       Yes       Yes     Yes             Terminated
#  SIGURG        No        No      Yes             Urgent I/O condition
#  SIGSTOP       Yes       Yes     Yes             Stopped (signal)
#  SIGTSTP       Yes       Yes     Yes             Stopped (user)
#  SIGCONT       Yes       Yes     Yes             Continued
#  SIGCHLD       No        No      Yes             Child status changed
#  SIGTTIN       Yes       Yes     Yes             Stopped (tty input)
#  SIGTTOU       Yes       Yes     Yes             Stopped (tty output)
#  SIGIO         No        No      Yes             I/O possible
#  SIGXCPU       Yes       Yes     Yes             CPU time limit exceeded
#  SIGXFSZ       Yes       Yes     Yes             File size limit exceeded
#  SIGVTALRM     No        No      Yes             Virtual timer expired
#  SIGPROF       No        No      Yes             Profiling timer expired
#  SIGWINCH      No        No      Yes             Window size changed
#  SIGLOST       Yes       Yes     Yes             Resource lost
#  SIGUSR1       Yes       Yes     Yes             User defined signal 1
#  SIGUSR2       Yes       Yes     Yes             User defined signal 2
#  SIGPWR        Yes       Yes     Yes             Power fail/restart
#  SIGPOLL       No        No      Yes             Pollable event occurred
#  SIGWIND       Yes       Yes     Yes             SIGWIND
#  SIGPHONE      Yes       Yes     Yes             SIGPHONE
#  SIGWAITING    No        No      Yes             Process's LWPs are blocked
#  SIGLWP        No        No      Yes             Signal LWP
#  SIGDANGER     Yes       Yes     Yes             Swap space dangerously low
#  SIGGRANT      Yes       Yes     Yes             Monitor mode granted
#  SIGRETRACT    Yes       Yes     Yes             Need to relinquish monitor mode
#  SIGMSG        Yes       Yes     Yes             Monitor mode data available
#  SIGSOUND      Yes       Yes     Yes             Sound completed
#  SIGSAK        Yes       Yes     Yes             Secure attention
#  SIGPRIO       Yes       Yes     Yes             SIGPRIO
#  SIG33         Yes       Yes     Yes             Real-time event 33
#  SIG34         No        No      Yes             Real-time event 34
#  SIG35         Yes       Yes     Yes             Real-time event 35
#  [...]
#  SIG127        Yes       Yes     Yes             Real-time event 127
#  SIGINFO       Yes       Yes     Yes             Information request
#  EXC_BAD_ACCESS Yes      Yes     Yes             Could not access memory
#  EXC_BAD_INSTRUCTION Yes Yes     Yes             Illegal instruction/operand
#  EXC_ARITHMETIC Yes      Yes     Yes             Arithmetic exception
#  EXC_EMULATION Yes       Yes     Yes             Emulation instruction
#  EXC_SOFTWARE  Yes       Yes     Yes             Software generated exception
#  EXC_BREAKPOINT Yes      Yes     Yes             Breakpoint
#
#  Use the "handle" command to change these tables.
#  (gdb)

gdb_test "continue" \
    ".*\[\r\n\]+Continuing\[^\r\n\]+\[\r\n\].*" \
    "continue program"

# ... ?

if { $local_test_running != 0 } {
    # MAYBE: FIXME: kill the program
}

return 0
# }}}

# trace-signals.exp {{{
# Test attaching to already-running programs using extended-remote.

load_lib gdbserver-support.exp
load_lib trace-support.exp

standard_testfile

if { [skip_gdbserver_tests] } {
    return 0
}

# We need to use TCL's exec to get the pid.
if [is_remote target] then {
    return 0
}

if {[prepare_for_testing $testfile.exp $testfile $srcfile debug]} {
    return -1
}

# Make sure we're disconnected, in case we're testing with an
# extended-remote board, therefore already connected.
gdb_test "disconnect" ".*"

set target_exec [gdbserver_download_current_prog]
gdbserver_start_extended

gdb_test_no_output "set remote exec-file $target_exec" "set remote exec-file"

# Start the program running and then wait for a bit, to be sure
# that it can be attached to.
set testpid [eval exec $binfile &]
exec sleep 2
if { [istarget "*-*-cygwin*"] } {
    # testpid is the Cygwin PID, GDB uses the Windows PID, which might be
    # different due to the way fork/exec works.
    set testpid [ exec ps -e | gawk "{ if (\$1 == $testpid) print \$4; }" ]
}

gdb_test "attach $testpid" \
    "Attaching to program: .*, process $testpid.*(in|at).*" \
    "attach to remote program 1"

if { [gdb_target_supports_trace] } then {
    # Test predefined TSVs are uploaded.
    gdb_test_sequence "info tvariables" "check uploaded tsv" {
	"\[\r\n\]+Name\[\t \]+Initial\[\t \]+Current"
	"\[\r\n\]+\\\$trace_timestamp 0"
    }
}

gdb_test "backtrace" ".*main.*" "backtrace 1"

gdb_test "detach" "Detaching from program.*process.*"
gdb_test "backtrace" "No stack\\." "backtrace with no program"

gdb_test "attach $testpid" \
    "Attaching to program: .*, process $testpid.*(in|at).*" \
    "attach to remote program 2"
gdb_test "backtrace" ".*main.*" "backtrace 2"

gdb_test "kill" "" "kill" "Kill the program being debugged.*" "y"
gdb_test_no_output "monitor exit"
# }}}

# gdb/testsuite/gdb.server/server-mon.exp {{{
# Test gdbserver monitor commands.

load_lib gdbserver-support.exp

standard_testfile server.c

if { [skip_gdbserver_tests] } {
    return 0
}

if {[prepare_for_testing $testfile.exp $testfile $srcfile debug]} {
    return -1
}

# Make sure we're disconnected, in case we're testing with an
# extended-remote board, therefore already connected.
gdb_test "disconnect" ".*"

gdbserver_run ""

gdb_test_multiple "monitor help" "monitor help" {
    -re "Unknown monitor command.*$gdb_prompt $" {
	fail "monitor help"
    }
    -re "The following monitor commands.*$gdb_prompt $" {
	pass "monitor help"
    }
}

gdb_test "monitor" "Unknown monitor command.*Protocol error.*"

gdb_test "monitor set debug 1" "Debug output enabled\\."
gdb_test "monitor set debug 0" "Debug output disabled\\."
gdb_test "monitor set remote-debug 1" "Protocol debug output enabled\\."
gdb_test "monitor set remote-debug 0" "Protocol debug output disabled\\."
gdb_test "monitor set debug-format all" \
    "All extra debug format options enabled\\."
gdb_test "monitor set debug-format none" \
    "All extra debug format options disabled\\."
# }}}
